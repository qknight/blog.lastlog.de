<!DOCTYPE html>
<!-- this document is auto-generated from pankat document editor -->
<html xmlns="http://www.w3.org/1999/xhtml">

<head data-article-dst-filename="qgraphicsscene_used_as_a_qabstractitemview.html">

<meta charset="utf-8" />
<meta content="IE=edge" http-equiv="X-UA-Compatible">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>qgraphicsscene used as a qabstractitemview</title>

<script src="js/jquery.min.js"></script>

<script src="js/jquery-ui-1.9.1.custom.min.js"></script>
<script src="js/jquery.tocify.min.js"></script>

<link type="text/css" rel="stylesheet" href="css/jquery.tocify.css" />



<script src="js/reconnecting-websocket.min.js"></script>
<script src="js/pankat-websocket.js"></script>
<script src="js/diffDOM.js"></script>


<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
<script src="js/bootstrap.min.js"></script>

<script src="js/anchor.min.js"></script>

<link rel="icon" href="media/favicon.ico" type="image/x-icon" />


<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
<![endif]-->
<link rel="stylesheet" href="css/pandoc-kate.css" type="text/css" />
<link rel="stylesheet" href="css/style.css" type="text/css" />

</head>
<body>

<div id="toc"></div>

<!-- menu begins -->
<div class="container">
  <nav class="navbar navbar-default">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">lastlog.de/blog</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="timeline.html"><span class="glyphicon glyphicon-list" aria-hidden="true"></span> timeline</a></li>
        <li><a href="about.html"><span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> about</a></li>
        <li><a href="/draft" id="draft" style="display: none"><span class="glyphicon glyphicon-folder-open" aria-hidden="true"></span> draft</a></li>
        <li><a href="/draft?article=posts/roadmap.mdwn" id="roadmap" style="display: none"><span class="glyphicon glyphicon glyphicon-road" aria-hidden="true"></span> roadmap</a></li>

      </ul>

      <ul class="nav navbar-nav navbar-right">
        <li><a title="live updates of article updates on posts/qgraphicsscene/qgraphicsscene_used_as_a_qabstractitemview.mdwn" id="websocket" style="display: none"><span id="websocketStatus" class="glyphicon glyphicon-remove" aria-hidden="true"></span> websocket</a></li>
        <!-- <li><a href="#">Login</a></li> -->
      </ul>

      <!--<div id="right">
        <form class="navbar-form navbar-right">
          <div class="form-group">
            <input type="text" class="form-control" placeholder="Search">
          </div>
        </form>
      </div>-->
    </div><!-- /.navbar-collapse -->
  </nav>

<div id="headerAndArticle">


  <div id="headerContainer">
    <header class="header"><span id="articleNavLeft"> <a href="cmake_kdevelop_4.html"> 
      <span class="glyphiconLink glyphicon glyphicon-chevron-left" aria-hidden="true" title="previous article"> </span> prev. article
    </a> </span><span id="articleNavRight"><a href="linux_bashing.html"> 
        next article <span class="glyphiconLink glyphicon glyphicon-chevron-right" aria-hidden="true" title="next article"></span>
    </a> </span></header>
  </div>
  
      <div id="seriesContainer">
      <a href="timeline.html?filter=series::qgraphicsscene" title="article series qgraphicsscene" class="seriesbtn btn btn-primary">qgraphicsscene</a>
        <header class="seriesHeader">
          <div id="seriesLeft">  </div>
          <div id="seriesRight">   <a href="qgraphicsscene_used_as_a_qabstractitemview_ii.html">
              <span class="glyphiconLinkSeries glyphicon glyphicon-chevron-right" aria-hidden="true" title="next article in series"></span>
            </a></div>
        </header>
      </div>

  <div class="article">
    <h1 id="SiteTitle">qgraphicsscene used as a qabstractitemview</h1>
    <div id="date"><p><span id="lastupdated">10 dec 2009</span></p></div><div id="tags"><p><a href="timeline.html?filter=tag::qt" class="tagbtn btn btn-primary">qt</a><a href="timeline.html?filter=tag::technology" class="tagbtn btn btn-primary">technology</a><a href="timeline.html?filter=tag::usability" class="tagbtn btn btn-primary">usability</a><a href="timeline.html?filter=tag::visualization" class="tagbtn btn btn-primary">visualization</a></p></div>
    <h2 data-number="1" id="motivation">motivation</h2>
<p>I’ve once written a <strong>qt4</strong> program which does use the
<strong>QGraphicsScene</strong> in a very unique way. Since i need the
same concept for another project i started to read the code i’ve written
quite some time ago. The code [1] is very complex so i got lost very
soon but as a solution i came up with this <strong>graph</strong>,
‘<strong>illustrating the concept and the class design</strong>’. There
was a feature i wanted to add and it might sound funny but i used this
graph ‘as a map’ to navigate through the source.</p>
<p><a href="media/graphicssceneasabstractitemview.png"><img src=media/graphicssceneasabstractitemview.png size=800x caption="QGraphicsScene used as a QAbstractItemView"></a></p>
<p>First a few words on the graph:</p>
<p>If you want to do the same thing keep in mind that** every layer of
abstraction duplicates the data once per instance** but <strong>the data
acquired through the model is the only data which is
authoritative</strong>. All other copies are for caching purpose and to
keep structural integrity for instance a QGraphicsScene needs all items
to be placed on the scene this way it is easier for the programmer.</p>
<p>In the early design phase i thought it would be
<strong>efficient</strong> to <strong>render only the part of the scene
which is actually visible</strong>. QGraphicsScene can’t be seen by
definition. It is the QGraphicsView which attaches to the scene and
which then visualizes the part of the scene (or the whole scene) if it’s
viewport is configured to do so. Taken efficiency into account rendering
only ‘what is seen’’ is already given but we have to insert all the
nodes and connections into the QGraphisScene. <strong>It is important to
know that a QGraphisScene is also a model based design</strong> that’s
why a single QGraphisScene can have several different QGraphisView
attached to it. One can be rotated, the other can be zoomed out - do
with it whatever you desire. <strong>All i did was wrapping the
QGraphisScene’s model into another layer</strong>.</p>
<p>We currently have 4 layers and we have to wrap something 3 times:</p>
<ul>
<li>first we wrap the data to be used by the model, this happens with
QModelIndex()es</li>
<li>second we wrap QModelIndex()es into QPersistentModelIndexes()</li>
<li>third we wrap QPersistentModelIndexes() into QGraphicsItems()</li>
</ul>
<p><strong>So one might wonder why did i NOT use the QAbstractItemView
in the first place?</strong> This is probably the most important
question!</p>
<p>A <strong>QAbstractItemView</strong> gives you a paint() function and
you have to draw the scene yourself. There is an excellent example
called ‘chart example’, see [2]. It might be a very good solution for
many problems which don’t require complex ‘user &lt;-&gt; item’
interaction - think of ‘move a node or you click a node’. (please play
with the example, and look at the code).</p>
<p>A <strong>QGraphicsScene</strong> has it’s own model which handles
all the items. Items can have various attributes as
moveable/clickable/selectable. You can layer items so that they have
individual or group rotation properties. You can use predefined items or
you can create your own. A very important point is you have a collision
detection and items can be clicked by the mouse and items can even
receive keyboard input. See example [3].</p>
<p>It should be clear now that a ‘graph editor’ needs all the later
mentioned capabilities.</p>
<p>I want to discuss several things:</p>
<ol type="1">
<li>inserting/deleting items with the graphical editor</li>
<li>how to read and write data seen from a QGraphicsItem</li>
<li>why i used properties instead of another hierarchy layer</li>
<li>why GraphicsItems access the model NOT being just a delegate</li>
</ol>
<h3 data-number="1.1"
id="insertingdeleting-items-with-the-graphical-editor">1.
inserting/deleting items with the graphical editor</h3>
<p>the fundamental concept is: “data is only inserted/deleted through
the model”. The model is the most important component in MVC [4]
abstraction. If you add a node with the gui you can either place the
node by random (which is what i do mainly) or you can query the mouse
position (if the mouse is hoovering above the QGraphicsView) and map it
to the QGraphicsScene coordinates and finally you ask the model to add a
node with addNode(coordinates) using the models public interface which
can be accessed from the <strong>G</strong>raphics<strong>V</strong>iew
(<strong>NOT</strong> QGraphicsView). The model will add a new item at
the data layer and the data layer will delegate the ‘added’ item upwards
in the hierarchy.</p>
<p>That’s why there are functions with <strong>active</strong> and
<strong>passive</strong> names as:</p>
<ul>
<li>insertNode()</li>
<li>nodeInserted()</li>
</ul>
<p>The first is an interface to add nodes. The second will be called
when the updated is delegated upwards. You never call a passive named
function directly since it is ONLY called by the
QAbstractItemModel/QAbstractItemView code.</p>
<p>Removing items is basically the same but now you have an
<strong>identifier</strong>. A item is removed based on it’s
<strong>identifier</strong> which <strong>can be a QPersistentModelIndex
for example</strong>.</p>
<h3 data-number="1.2"
id="how-to-read-and-write-data-seen-from-a-qgraphicsitem">2. how to read
and write data seen from a QGraphicsItem</h3>
<p>A QGraphicsItem (and all derived types) live in the QGraphisScene and
don’t have access to the model. It is conceptually easy to generate such
an object based on the information given by the model (read
<strong>simplex</strong> communication here) - which can be done in the
init() function when the view is initialized and filled with all nodes
and node connections.</p>
<p>However it can be challenging creating a backward communication
channel (read <strong>duplex</strong>, bidirectional). In an ideal world
this would be done in a way that a AbstractGraphicsItem inherits from
QGraphicsItem. This AbstractGraphicsItem then is specialized in
NodeGraphicsItem and into a ConnectionGraphisItem.</p>
<p>The AbstractGraphicsItem would add the communication layer (this is
not done in my example). The specialization layer would do the custom
drawing stuff as a node is drawn differently than a node_connection.</p>
<p>In my example the QGraphicsScene does setData() and data() wrapping.
This is a hack which works nice but i’d prefer the delegate design now
since it is a clear interface design.</p>
<p>Most properties are set/queried by: <strong>model-&gt;data(),
model-&gt;setData()</strong>. One problem for example is when you move
one item. Would it make sense to update the position through the model?
Probably not since this would slow down the whole operation. Since the
QGraphicsScene provides a signal which is emiteed when an moved item is
released this signal could be used to update the position of the item
through the model. This operation is <strong>asynchronous</strong>.</p>
<p>For all other properties as ‘node label’ and ‘node_connection color’
and similar it only makes sense to use model-&gt;setData() and wait for
the model to update the item (which just asked ‘could you please update
my color?’). This operation is absolutely
<strong>synchronous</strong>.</p>
<h3 data-number="1.3"
id="why-i-used-properties-instead-of-another-hierarchy-layer">3. why i
used properties instead of another hierarchy layer</h3>
<p>I’m not sure on this yet and i think i have to think about this more
time. However i share some thoughts.</p>
<p>my data currently has these 3 types:</p>
<ul>
<li>ROOT_NODE</li>
<li>NODE</li>
<li>NODE_CONNECTION</li>
</ul>
<p>and properties for node as for example: nodelabel, startflag, final
flag (yes NFA/DFA/… do you remember?) why not add another type called
PROPERTY instead of using setProperty() and property() (which is
provided by QObject).</p>
<p>i call the type approach (using PROPERTY) from now on:
‘<strong>typeapproach</strong>’ and the QObject::property() approach i
call ‘<strong>qobjectproperty</strong>’.</p>
<p>In either concept the model code would not be that different. Using
QObject::properties one would (as i did) use data() and setData() and
query the needed information - a QVariants is returned and automatically
converted to a type usable by the view.</p>
<p>The most significant difference when using the ‘typeapproach’ would
be the updates for the items in the QGraphisScene. One would have a
QPersistentModelIndex() per property (nodelabel/start flag/final flag)
and one would instantly know what to change when updateData() want’s the
QGraphicsItem to change it’s label. Currently i’m using the
‘qobjectproperty’ and i have to check all those properties every time
updateData() is called.</p>
<p><strong>I’m not sure what is the best strategy but i would guess the
‘typeapproach’ could be very interesting.</strong></p>
<h3 data-number="1.4"
id="why-graphicsitems-access-the-model-not-being-just-a-delegate">4. why
GraphicsItems access the model NOT being just a delegate</h3>
<p>as mentioned earlier this would be the best design. if an item of
type NODE is required a respective QGraphicsItem, say a NodeGraphicsItem
is synthesized. i probably will use this design for the next
project.</p>
<h2 data-number="2" id="some-final-words">some final words</h2>
<p>i’ve written this page for myself since i’m currently planning a
similar project using a QAbstractItemModel with a QGraphicsScene. but as
this subject is complex i’d like to share this with anyone out
there.</p>
<p>if you have some thoughts on this, please let me know by email:_ js
adt lastlog dodt de_</p>
<h2 data-number="3" id="links">links</h2>
<ul>
<li>[1] <a href="http://lastlog.de/wiki/index.php/AutomateEditor"
class="uri">http://lastlog.de/wiki/index.php/AutomateEditor</a></li>
<li>[2] <a href="http://doc.trolltech.com/4.1/itemviews-chart.html"
class="uri">http://doc.trolltech.com/4.1/itemviews-chart.html</a></li>
<li>[3] <a
href="http://doc.trolltech.com/4.3/graphicsview-collidingmice.html"
class="uri">http://doc.trolltech.com/4.3/graphicsview-collidingmice.html</a></li>
<li>[4] <a href="http://de.wikipedia.org/wiki/Model_View_Controller"
class="uri">http://de.wikipedia.org/wiki/Model_View_Controller</a></li>
<li>[5] <a
href="http://doc.trolltech.com/4.2/itemviews-simpletreemodel.html"
class="uri">http://doc.trolltech.com/4.2/itemviews-simpletreemodel.html</a></li>
</ul>
<h2 data-number="4" id="updates">updates</h2>
<p>(13.12.2009) the title of this document was of course wrong, it must
be: QGraphicsScene used as a <strong>QAbstractItemView </strong>and not
‘used as a QAbstractItemModel’ ;P</p>
<p>the example for the low level ‘data’ structure which is refered as
simpletreeexample is actually called ‘simple tree model’ example, see
[5]</p>

  </div>

</div>

<div id="ArticleSourceCode">

<a href="posts/qgraphicsscene/qgraphicsscene_used_as_a_qabstractitemview.mdwn" title="posts\qgraphicsscene\qgraphicsscene_used_as_a_qabstractitemview.mdwn">article source</a>
</div>

</div>

<div id="scrollUp">
<span id="scrollUpBtn" class="glyphiconLink glyphicon glyphicon-chevron-up" aria-hidden="true" title="scroll up"></span>
</div>

<script>
$("#scrollUpBtn").click(function() {
  $("html, body").animate({ scrollTop: 0 }, "slow");
  return false;
});
</script>


<script>
window.onload = function(e){
  anchors.add('h1')
  anchors.add('h2')
  anchors.add('h3')
  anchors.add('h4')
  anchors.add('h5')
}
</script>




<script>
$(document).ready(function() {
  //Calls the tocify method on your HTML div.
  $("#toc").tocify();
});
$("#toc").hover(function() {
  $("#toc").css("z-index", "111")
}, function() {
  $("#toc").css("z-index", "1")
});
</script>



<script>

var shifted = false;

$(window).keyup(function(event) {
    shifted = event.shiftKey;
});

$(window).keydown(function(event) {
  if(event.keyCode == 16){
    shifted = event.shiftKey;
  }
  if (shifted == false) {
      if(event.keyCode == 37){
        $('.glyphicon-chevron-left')[0].click()
      }
      if(event.keyCode == 39){
        $('.glyphicon-chevron-right')[0].click()
      }
  }
});
</script>


<script>
// check if we got served from pankat-server
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
  if (xhr.status == 200) {
    console.log("request to /pankat-server returned status: " + xhr.status + ", so yes we got served from pankat-server");
    $('#draft').css("display", "block");
    $('#roadmap').css("display", "block");
  }
}
}
xhr.open('GET', "/pankat-server", false);
xhr.send(null);
</script>
</body>
</html>
